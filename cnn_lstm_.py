# -*- coding: utf-8 -*-
"""CNN_LSTM .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12bQ7zlFt1A1uKoVkIIx1Y0-vS1-Q1I4Y
"""

import os
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import numpy as np

# Check if GPU is available and use it
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# 1. Define Paths for Your Datasets
train_data_dir = '/content/drive/MyDrive/6k_800_800/Train'
val_data_dir = '/content/drive/MyDrive/6k_800_800/Valiadation'
test_data_dir = '/content/drive/MyDrive/6k_800_800/Test'


from google.colab import drive
drive.mount('/content/drive')

# 2. Data Preprocessing
transform = transforms.Compose([
    transforms.Resize((224, 224)),  # Resize for CNN
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5])
])

# Load datasets
print("Loading datasets...")
train_dataset = datasets.ImageFolder(root=train_data_dir, transform=transform)
val_dataset = datasets.ImageFolder(root=val_data_dir, transform=transform)
test_dataset = datasets.ImageFolder(root=test_data_dir, transform=transform)

# Create DataLoaders
train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=16, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=1, shuffle=False)

print("Datasets loaded successfully!")

# 3. Define the Hybrid CNN-LSTM Model
class HybridCNNLSTM(nn.Module):
    def __init__(self, num_classes=2):
        super(HybridCNNLSTM, self).__init__()
        # Pretrained CNN (e.g., ResNet50)
        self.cnn = nn.Sequential(
            nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2, stride=2)
        )
        self.flatten_size = 128 * 56 * 56  # Adjust based on CNN output size
        self.lstm = nn.LSTM(input_size=self.flatten_size, hidden_size=256, num_layers=2, batch_first=True)
        self.fc = nn.Linear(256, num_classes)

    def forward(self, x):
        batch_size, time_steps, c, h, w = x.size()
        cnn_out = torch.zeros(batch_size, time_steps, self.flatten_size).to(device)
        for t in range(time_steps):
            cnn_out[:, t, :] = self.cnn(x[:, t, :, :, :]).view(batch_size, -1)
        lstm_out, _ = self.lstm(cnn_out)
        final_out = self.fc(lstm_out[:, -1, :])  # Take the output from the last time step
        return final_out

model = HybridCNNLSTM(num_classes=2).to(device)

# 4. Loss Function and Optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.AdamW(model.parameters(), lr=1e-4, weight_decay=1e-5)

# 5. Training Function
def train_model(model, train_loader, val_loader, criterion, optimizer, num_epochs=10):
    best_val_loss = float('inf')
    for epoch in range(num_epochs):
        print(f"Epoch {epoch+1}/{num_epochs}")
        model.train()
        running_loss, correct, total = 0.0, 0, 0

        for inputs, labels in train_loader:
            batch_size = inputs.size(0)
            inputs = inputs.view(batch_size, 1, 3, 224, 224).to(device)  # Add time step dimension
            labels = labels.to(device)
            optimizer.zero_grad()

            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            _, preds = torch.max(outputs, 1)
            running_loss += loss.item()
            correct += (preds == labels).sum().item()
            total += labels.size(0)

        train_loss = running_loss / len(train_loader)
        train_acc = correct / total * 100
        val_loss, val_acc = validate_model(model, val_loader, criterion)

        print(f"Train Loss: {train_loss:.4f}, Train Accuracy: {train_acc:.2f}%")
        print(f"Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_acc:.2f}%\n")

# 6. Validation Function
def validate_model(model, val_loader, criterion):
    model.eval()
    running_loss, correct, total = 0.0, 0, 0

    with torch.no_grad():
        for inputs, labels in val_loader:
            batch_size = inputs.size(0)
            inputs = inputs.view(batch_size, 1, 3, 224, 224).to(device)  # Add time step dimension
            labels = labels.to(device)

            outputs = model(inputs)
            loss = criterion(outputs, labels)

            _, preds = torch.max(outputs, 1)
            running_loss += loss.item()
            correct += (preds == labels).sum().item()
            total += labels.size(0)

    val_loss = running_loss / len(val_loader)
    val_acc = correct / total * 100
    return val_loss, val_acc

# 7. Train the Model
print("Starting training...")
train_model(model, train_loader, val_loader, criterion, optimizer, num_epochs=10)
print("Training completed!")

# 8. Testing the Model
model.eval()
true_labels = []
predicted_labels = []

with torch.no_grad():
    for inputs, labels in test_loader:
        batch_size = inputs.size(0)
        inputs = inputs.view(batch_size, 1, 3, 224, 224).to(device)  # Add time step dimension
        labels = labels.to(device)

        outputs = model(inputs)
        _, preds = torch.max(outputs, 1)

        true_labels.extend(labels.cpu().numpy())
        predicted_labels.extend(preds.cpu().numpy())

true_labels = np.array(true_labels)
predicted_labels = np.array(predicted_labels)

print("Classification Report:")
print(classification_report(true_labels, predicted_labels, target_names=["Real", "Fake"]))

cm = confusion_matrix(true_labels, predicted_labels)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=["Real", "Fake"])
disp.plot(cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.show()
